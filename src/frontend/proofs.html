<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Evidences | Villain Branding</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <style>
        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        .page-layout {
            margin-top: 2rem;
            margin-bottom: 2rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            transition: var(--transition);
            cursor: pointer;
        }

        .back-button:hover {
            color: var(--text-primary);
        }

        .back-button::before {
            content: '‚Üê';
            font-size: 1.2rem;
        }

        .sticky-header-section {
            background-color: var(--bg-primary);
            z-index: 80;
            padding-top: 1rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
            margin-bottom: 1.5rem;
            flex-shrink: 0;
            width: 100%;
            max-width: var(--container-width);
            margin-left: auto;
            margin-right: auto;
            padding-left: 2rem;
            padding-right: 2rem;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
        }

        .scrollable-proofs-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 0.5rem;
            /* Hide scrollbar for Chrome, Safari and Opera */
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE and Edge */
        }

        .scrollable-proofs-container::-webkit-scrollbar {
            display: none;
        }

        .proofs-container {
            display: flex;
            flex-direction: column;
            gap: 3rem;
        }

        .date-group {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 1.5rem;
        }

        .date-label {
            width: 100%;
            padding: 1rem 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            position: sticky;
            top: 0;
            background-color: var(--bg-primary);
            z-index: 10;
            border-bottom: 1px solid var(--border);
        }

        .batch-group {
            margin-bottom: 2rem;
        }

        .batch-label {
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 2px solid var(--accent);
        }

        .status-indicator {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 4px;
            z-index: 5;
        }

        .status-pending {
            background: rgba(234, 179, 8, 0.2);
            color: #eab308;
        }

        .status-processing {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .status-success {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .status-failed {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .date-proofs {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
        }

        @media (max-width: 1100px) {
            .date-proofs {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .date-proofs {
                grid-template-columns: 1fr;
            }
        }

        .proofs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 2rem;
        }

        .proof-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .proof-image-container {
            width: 100%;
            height: 300px;
            background: #000;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid var(--border);
            position: relative;
        }

        .proof-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: top;
            display: block;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease;
            border-bottom: none;
            /* Removed as container has border */
        }

        .proof-image:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        .proof-placeholder {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
        }

        .proof-content {
            padding: 1.5rem;
        }

        .proof-text {
            font-family: var(--font-serif);
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .proof-meta {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: var(--font-sans);
        }

        .found-on-display {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: var(--radius-pill);
            color: var(--text-primary);
            font-weight: 500;
            text-decoration: none;
            transition: var(--transition);
            margin-left: 0.25rem;
        }

        .found-on-display:hover {
            background: rgba(212, 175, 55, 0.25);
            border-color: rgba(212, 175, 55, 0.5);
            transform: translateY(-1px);
        }

        .proof-card {
            position: relative;
        }

        .delete-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--border);
            color: var(--text-primary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            font-size: 1.2rem;
            opacity: 0;
        }

        .proof-card:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn:hover {
            background: rgba(220, 38, 38, 0.9);
            border-color: #dc2626;
            color: white;
            transform: scale(1.1);
        }

        .edit-btn {
            position: absolute;
            top: 1rem;
            right: 4rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--border);
            color: var(--text-primary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            font-size: 1rem;
            opacity: 0;
        }

        .proof-card:hover .edit-btn {
            opacity: 1;
        }

        .edit-btn:hover {
            background: rgba(59, 130, 246, 0.9);
            border-color: #3b82f6;
            color: white;
            transform: scale(1.1);
        }

        /* Cropper Modal */
        .crop-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .crop-modal.active {
            display: flex;
        }

        .crop-container {
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 2rem;
            position: relative;
        }

        .crop-image-container {
            width: 100%;
            max-height: 60vh;
            overflow: hidden;
            margin-bottom: 1.5rem;
        }

        .crop-image-container img {
            max-width: 100%;
            max-height: 60vh;
        }

        .crop-controls {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            align-items: center;
        }

        .save-button-group {
            display: flex;
            align-items: stretch;
            border-radius: var(--radius-pill);
            overflow: hidden;
            border: 1px solid var(--text-primary);
        }

        .save-button-group select {
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-right: 1px solid rgba(15, 15, 15, 0.2);
            padding: 0.8rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            letter-spacing: 0.02em;
            font-family: var(--font-sans);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%230f0f0f' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2.5rem;
        }

        .save-button-group select:hover {
            background: #e0e0e0;
        }

        .save-button-group select:focus {
            outline: none;
        }

        .save-button-group .btn-primary {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-top-right-radius: var(--radius-pill);
            border-bottom-right-radius: var(--radius-pill);
            border-left: none;
            margin: 0;
            padding: 0.8rem 2rem;
        }

        .close-crop-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--border);
            color: var(--text-primary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
        }

        .close-crop-modal:hover {
            background: rgba(220, 38, 38, 0.9);
            border-color: #dc2626;
            color: white;
        }

        /* Lightbox Modal */
        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1500;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .lightbox.active {
            display: flex;
            opacity: 1;
        }

        .lightbox-content {
            max-width: 95%;
            max-height: 95vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox-img {
            max-width: 100%;
            max-height: 95vh;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .close-lightbox {
            position: absolute;
            top: -3rem;
            right: 0;
            color: white;
            font-size: 2.5rem;
            cursor: pointer;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .close-lightbox:hover {
            background: rgba(220, 38, 38, 0.9);
            transform: scale(1.1);
        }

        /* Loader Styles */
        .screenshot-loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 300px;
            background: var(--bg-primary);
            border: 1px dashed var(--border);
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(212, 175, 55, 0.2);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loader-text {
            color: var(--text-secondary);
            font-size: 1rem;
            margin-top: 0.5rem;
        }
    </style>
</head>

<body>
    <header class="site-header">
        <div class="container nav-container">
            <div class="logo" onclick="window.location.href='index.html'" style="cursor: pointer;">
                VILLAIN <span>BRANDING‚Ñ¢</span>
            </div>
            <nav class="nav-links">
                <a href="index.html" class="nav-link">DASHBOARD</a>
                <a href="#" class="nav-link" id="navMessages">MESSAGES</a>
                <a href="#" class="nav-link active">EVIDENCES</a>
            </nav>
        </div>
    </header>

    <div class="container page-layout">
        <div style="flex-shrink: 0;">
            <!-- Back Button -->
            <a href="companies-proofs.html" class="back-button">Back</a>

            <!-- Sticky Header Section -->
            <div class="sticky-header-section">
                <div class="header-row">
                    <div>
                        <h1 id="companyName">Loading...</h1>
                        <p class="text-muted">Visual Evidences</p>
                    </div>
                    <div>
                        <button class="btn btn-secondary" id="exportEvidencesBtn" onclick="exportEvidences()">
                            EXPORT EVIDENCES
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scrollable Proofs Grid -->
        <div class="scrollable-proofs-container">
            <div id="proofsGrid" class="proofs-container">
                <!-- Evidences injected here -->
                <div class="text-center" style="padding: 4rem;">
                    <div class="spinner" style="margin: 0 auto 1rem;"></div>
                    <p class="text-muted">Generating screenshots...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Lightbox Modal -->
    <div id="lightbox" class="lightbox">
        <div class="lightbox-content">
            <span class="close-lightbox" onclick="closeLightbox()">&times;</span>
            <img src="" alt="Full size" class="lightbox-img" id="lightboxImg">
        </div>
    </div>

    <!-- Crop Modal -->
    <div id="cropModal" class="crop-modal">
        <div class="crop-container">
            <button class="close-crop-modal" onclick="closeCropModal()">√ó</button>
            <h2 style="margin-bottom: 1.5rem; color: var(--text-primary);">Crop Image</h2>
            <div class="crop-image-container">
                <img id="cropImage" src="" alt="Image to crop">
            </div>
            <div class="crop-controls">
                <button class="btn btn-secondary" onclick="closeCropModal()">Cancel</button>
                <div class="save-button-group">
                    <select id="saveModeSelect">
                        <option value="copy" selected>Save as Copy</option>
                        <option value="replace">Replace Original</option>
                    </select>
                    <button class="btn btn-primary" onclick="saveCroppedImage()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="js/app.js"></script>
    <script>
        // Evidences Page Logic
        const companyId = window.api.getCompanyId();
        const companyName = document.getElementById('companyName');
        const proofsGrid = document.getElementById('proofsGrid');
        let currentCompany = null; // Store company data for use in rendering

        // Update Nav Links
        window.api.updateNavLinks(companyId);

        async function init() {
            if (!companyId) {
                window.location.href = 'companies.html';
                return;
            }

            try {
                // Fetch company info (optional, for header)
                const companies = await window.api.getCompanies();
                const company = companies.find(c => c.id === companyId);
                if (company) {
                    currentCompany = company; // Store for use in rendering
                    document.getElementById('companyName').textContent = company.name || company.domain;
                }

                // Fetch messages with their locations
                const messages = await window.api.getCompanyMessages(companyId);

                // Fetch existing screenshots
                const existingEvidences = await window.api.getScreenshots(companyId);

                // Render all pages from messages with re-capture option
                renderAllPages(messages, existingEvidences, currentCompany);

                // Check if we should start polling (came from generate button)
                const urlParams = new URLSearchParams(window.location.search);
                const batchId = urlParams.get('batchId');
                if (batchId || sessionStorage.getItem('pendingScreenshots')) {
                    startPolling(batchId);
                }
            } catch (error) {
                console.error('Error loading proofs:', error);
                document.getElementById('proofsGrid').innerHTML = `<p class="text-center text-error">Failed to load proofs.</p>`;
            }
        }

        // Helper function to format date as "Jan 5, 2026"
        function formatDate(dateString) {
            if (!dateString) return 'Unknown Date';
            const date = new Date(dateString);
            const options = { month: 'short', day: 'numeric', year: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Helper function to get date key (YYYY-MM-DD) for grouping
        function getDateKey(dateString) {
            if (!dateString) return 'unknown';
            const date = new Date(dateString);
            return date.toISOString().split('T')[0];
        }

        // Helper function to group screenshots by date
        function groupByDate(screenshots) {
            const groups = new Map();

            screenshots.forEach(proof => {
                const dateKey = getDateKey(proof.created_at);
                if (!groups.has(dateKey)) {
                    groups.set(dateKey, []);
                }
                groups.get(dateKey).push(proof);
            });

            // Convert to array and sort by date (descending - latest first)
            return Array.from(groups.entries())
                .sort((a, b) => b[0].localeCompare(a[0])); // Sort dates descending
        }

        // Helper function to group screenshots within a date by batch_id
        function groupByBatch(screenshots) {
            const batchGroups = new Map();

            screenshots.forEach(proof => {
                // Use batch_id if available, otherwise use created_at timestamp (rounded to minute)
                const batchKey = proof.batch_id || getTimeKey(proof.created_at);
                if (!batchGroups.has(batchKey)) {
                    batchGroups.set(batchKey, {
                        proofs: [],
                        timestamp: proof.created_at,
                        batchId: proof.batch_id
                    });
                }
                batchGroups.get(batchKey).proofs.push(proof);
            });

            // Sort batches descending (newest first) by timestamp
            return Array.from(batchGroups.entries()).sort((a, b) => {
                return new Date(b[1].timestamp) - new Date(a[1].timestamp);
            });
        }

        // Helper to get time key (for legacy screenshots without batch_id)
        function getTimeKey(dateString) {
            if (!dateString) return 'unknown';
            const date = new Date(dateString);
            const mins = Math.floor(date.getMinutes() / 5) * 5;
            return `${date.toISOString().split('T')[0]}-${date.getHours()}-${mins}`;
        }

        // Helper to format time for batch header
        function formatBatchTime(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        }


        // Helper function to render a single proof card
        function renderProofCard(proof, messagesMap, company) {
            const message = messagesMap.get(proof.message_id);
            const messageContent = message?.content || proof.message_content || 'Unknown message';
            const cardId = `proof-${proof.id}`;
            const isFailed = !proof.image_url || proof.status === 'failed';
            const isPending = proof.status === 'pending' || proof.status === 'processing';

            // Format URL for display
            let foundOnDisplay = 'Unknown page';
            let foundOnHref = '#';
            try {
                if (proof.original_url || proof.page_url) {
                    const urlStr = proof.original_url || proof.page_url;
                    const url = new URL(urlStr);
                    foundOnDisplay = url.pathname === '/' ? 'Homepage' : url.pathname;
                    foundOnHref = urlStr;
                }
            } catch (e) {
                console.warn('Invalid URL in proof:', proof.original_url || proof.page_url);
            }

            // Status indicator for pending/processing
            const statusIndicator = isPending ?
                `<div class="status-indicator status-${proof.status}">${proof.status.toUpperCase()}</div>` : '';

            return `
        <div class="proof-card" id="${cardId}" data-proof-id="${proof.id}" data-screenshot-id="${proof.id}">
          ${statusIndicator}
          <button class="delete-btn" onclick="deleteProof('${proof.id}', '${cardId}', event)" title="Delete screenshot">√ó</button>
          ${!isFailed && !isPending ? `<button class="edit-btn" onclick="editProof('${proof.id}', '${proof.image_url}', event)" title="Crop/Edit image">‚úé</button>` : ''}
          
          <div class="proof-image-container">
            ${isPending ? `
              <div class="screenshot-loader">
                <div class="spinner"></div>
                <div class="loader-text">${proof.status === 'processing' ? 'Capturing...' : 'Pending...'}</div>
              </div>
            ` : isFailed ? `
              <div class="proof-placeholder">
                <div style="text-align: center;">
                  <div style="color: #dc2626; margin-bottom: 0.5rem; font-size: 1.1rem;">‚ö†Ô∏è Failed to Capture</div>
                  <div style="margin-bottom: 0.5rem;">üì∑</div>
                  <div>Click RE-GENERATE to try again</div>
                </div>
              </div>
            ` : `
              <img src="${proof.image_url}" alt="Visual Proof" class="proof-image" onclick="openLightbox('${proof.image_url}')">
            `}
          </div>

          <div class="proof-content">
            <div class="proof-text">"${messageContent}"</div>
            <div class="proof-meta">
              Found on: <a href="${foundOnHref}" target="_blank" class="found-on-display">${foundOnDisplay}</a>
            </div>
            <div style="margin-top: 1.5rem;">
              <button class="btn btn-secondary re-capture-btn" 
                data-is-failed="${isFailed || isPending}"
                onclick="handleReCaptureOrDownload('${proof.message_id}', '${proof.original_url || proof.page_url}', '${messageContent.replace(/'/g, "\\'")}', '${proof.id}', '${proof.image_url}', ${isFailed || isPending}, event)">
                ${isFailed ? 'RE-GENERATE' : isPending ? 'PENDING...' : 'RE-CAPTURE'}
              </button>
            </div>
          </div>
        </div>
      `;
        }

        function renderAllPages(messages, existingEvidences, company) {
            const container = document.getElementById('proofsGrid');

            // Only show screenshots that have been generated (existingEvidences)
            if (!existingEvidences || existingEvidences.length === 0) {
                container.innerHTML = `< p class="text-center text-muted" > No screenshots generated yet.Go to Messages to generate screenshots.</p > `;
                return;
            }

            // Create a map of messages by ID for content lookup
            const messagesMap = new Map();
            if (messages) {
                messages.forEach(msg => {
                    messagesMap.set(msg.id, msg);
                });
            }

            // Group screenshots by date (already sorted by created_at desc from API)
            const dateGroups = groupByDate(existingEvidences);

            // Render date groups
            if (dateGroups.length === 0) {
                container.innerHTML = `<p class="text-center text-muted">No screenshots generated yet. Go to Messages to generate screenshots.</p>`;
                return;
            }

            // Render with batch sub-grouping
            container.innerHTML = dateGroups.map(([dateKey, proofs]) => {
                const formattedDate = formatDate(proofs[0].created_at);

                // Group proofs by batch within this date
                const batches = groupByBatch(proofs);

                const batchesHtml = batches.map(([batchKey, batchData], batchIndex) => {
                    const batchTime = formatBatchTime(batchData.timestamp);
                    const batchLabel = batchTime ? ` - ${batchTime}` : '';
                    const proofCards = batchData.proofs.map(proof => renderProofCard(proof, messagesMap, company)).join('');

                    return `
                        <div class="batch-group" data-batch-id="${batchData.batchId || batchKey}">
                            ${batches.length > 1 ? `<div class="batch-label">Batch ${batches.length - batchIndex}${batchLabel}</div>` : ''}
                            <div class="date-proofs">
                                ${proofCards}
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="date-group">
                        <div class="date-label">${formattedDate}</div>
                        ${batchesHtml}
                    </div>
                `;
            }).join('');
        }

        // Status polling for pending screenshots
        let pollingInterval = null;
        let pendingIds = [];

        async function startPolling(batchId) {
            const pendingData = sessionStorage.getItem('pendingScreenshots');
            if (!pendingData && !batchId) return;

            if (pendingData) {
                const pending = JSON.parse(pendingData);
                pendingIds = pending.map(p => p.id);
            }

            // If pendingIds is still empty but we have a batchId, get IDs from rendered cards
            if (pendingIds.length === 0) {
                const pendingCards = document.querySelectorAll('.proof-card .status-pending, .proof-card .status-processing');
                pendingCards.forEach(statusEl => {
                    const card = statusEl.closest('.proof-card');
                    if (card && card.dataset.screenshotId) {
                        pendingIds.push(card.dataset.screenshotId);
                    }
                });
            }

            if (pendingIds.length === 0) {
                console.log('[Polling] No pending screenshots found to poll');
                return;
            }

            console.log(`[Polling] Starting status polling for ${pendingIds.length} screenshots:`, pendingIds);


            pollingInterval = setInterval(async () => {
                try {
                    const idsParam = pendingIds.join(',');
                    // Add timestamp to prevent browser caching (304 responses)
                    const response = await fetch(`/api/screenshots/status?ids=${idsParam}&_t=${Date.now()}`, {
                        cache: 'no-store'
                    });
                    const data = await response.json();

                    if (!data.screenshots) return;

                    let allComplete = true;
                    data.screenshots.forEach(screenshot => {
                        const card = document.querySelector(`[data-screenshot-id="${screenshot.id}"]`);
                        if (!card) return;

                        // Update status indicator
                        const statusEl = card.querySelector('.status-indicator');
                        if (statusEl) {
                            statusEl.className = `status-indicator status-${screenshot.status}`;
                            statusEl.textContent = screenshot.status.toUpperCase();
                        }

                        // If completed, update the image
                        if (screenshot.status === 'success' && screenshot.image_url) {
                            const imgContainer = card.querySelector('.proof-image-container');
                            if (imgContainer) {
                                imgContainer.innerHTML = `<img src="${screenshot.image_url}" class="proof-image" onclick="openLightbox('${screenshot.image_url}')">`;
                            }
                            // Remove from pending
                            pendingIds = pendingIds.filter(id => id !== screenshot.id);
                        } else if (screenshot.status === 'failed') {
                            const imgContainer = card.querySelector('.proof-image-container');
                            if (imgContainer) {
                                imgContainer.innerHTML = `<div class="proof-placeholder"><div>Failed to capture<br><small>${screenshot.error_message || 'Unknown error'}</small></div></div>`;
                            }
                            pendingIds = pendingIds.filter(id => id !== screenshot.id);
                        } else {
                            allComplete = false;
                        }
                    });

                    if (allComplete || pendingIds.length === 0) {
                        console.log('[Polling] All screenshots complete, stopping poll');
                        clearInterval(pollingInterval);
                        sessionStorage.removeItem('pendingScreenshots');
                        sessionStorage.removeItem('currentBatchId');
                    }
                } catch (error) {
                    console.error('[Polling] Error:', error);
                }
            }, 2000); // Poll every 2 seconds
        }

        async function reCaptureScreenshot(messageId, url, text, screenshotId, event) {
            event.stopPropagation();

            // Validate inputs
            if (!url || url === '' || url === '#') {
                alert('Invalid URL. Cannot regenerate screenshot.');
                return;
            }

            if (!text || text === '') {
                alert('Message text is missing. Cannot regenerate screenshot.');
                return;
            }

            const button = event.target;
            const card = button.closest('.proof-card');
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'CAPTURING...';

            // Show loader in place of "Failed to Capture" message
            const placeholder = card.querySelector('.proof-placeholder');
            if (placeholder) {
                placeholder.className = 'screenshot-loader';
                placeholder.style.cssText = 'width: 100%; height: 300px; background: var(--bg-primary); border: 1px dashed var(--border); display: flex; flex-direction: column; align-items: center; justify-content: center;';
                placeholder.innerHTML = `
                < div class="spinner" ></div >
                    <div class="loader-text">Capturing screenshot...</div>
            `;
            }

            try {
                // Get company ID from URL or global
                const companyId = window.api.getCompanyId();
                if (!companyId) {
                    alert('Company ID not found');
                    button.disabled = false;
                    button.textContent = originalText;

                    // Restore "Failed to Capture" message
                    const placeholder = card.querySelector('.proof-placeholder, .screenshot-loader');
                    if (placeholder) {
                        placeholder.className = 'proof-placeholder';
                        placeholder.style.cssText = 'width: 100%; height: 300px; background: var(--bg-primary); border: 1px dashed var(--border); display: flex; align-items: center; justify-content: center; color: var(--text-muted);';
                        placeholder.innerHTML = `
                < div style = "text-align: center;" >
                                <div style="color: #dc2626; margin-bottom: 0.5rem; font-size: 1.1rem;">‚ö†Ô∏è Failed to Capture</div>
                                <div style="margin-bottom: 0.5rem;">üì∑</div>
                                <div>Click RE-GENERATE to try again</div>
                            </div >
                `;
                    }
                    return;
                }

                // If this is a re-generation of a failed screenshot, delete the old failed record first
                if (screenshotId && screenshotId !== 'undefined' && screenshotId !== 'null') {
                    try {
                        await window.api.deleteScreenshot(screenshotId);
                    } catch (e) {
                        console.warn('Could not delete old screenshot record:', e);
                        // Continue anyway
                    }
                }

                const result = await window.api.generateScreenshot(companyId, messageId, url, text);

                if (result && result.success) {
                    // Reload proofs
                    await init();
                    alert('Screenshot captured successfully!');
                } else {
                    // Reload to show the new failed attempt
                    await init();
                    alert('Failed to capture screenshot: ' + (result?.error || result?.details || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error capturing screenshot:', error);
                button.disabled = false;
                button.textContent = originalText;

                // Restore "Failed to Capture" message if loader was shown
                const placeholder = card.querySelector('.proof-placeholder, .screenshot-loader');
                if (placeholder && placeholder.classList.contains('screenshot-loader')) {
                    placeholder.innerHTML = `
                < div style = "text-align: center;" >
                            <div style="color: #dc2626; margin-bottom: 0.5rem; font-size: 1.1rem;">‚ö†Ô∏è Failed to Capture</div>
                            <div style="margin-bottom: 0.5rem;">üì∑</div>
                            <div>Click RE-GENERATE to try again</div>
                        </div >
                `;
                    placeholder.className = 'proof-placeholder';
                    placeholder.style.cssText = 'width: 100%; height: 300px; background: var(--bg-primary); border: 1px dashed var(--border); display: flex; align-items: center; justify-content: center; color: var(--text-muted);';
                }

                alert('Failed to capture screenshot: ' + (error.message || 'Please try again.'));
            }
        }


        async function deleteProof(screenshotId, cardId, event) {
            event.stopPropagation(); // Prevent image click

            const confirmed = await window.api.confirm('Are you sure you want to delete this screenshot? This action cannot be undone.', 'Delete Screenshot');
            if (!confirmed) {
                return;
            }

            try {
                // Find the card first
                const card = cardId ? document.getElementById(cardId) : document.querySelector(`[data - proof - id="${screenshotId}"]`);

                // Delete from database
                await window.api.deleteScreenshot(screenshotId);

                if (card) {
                    // Find the date-proofs container and date-group
                    const dateProofsContainer = card.closest('.date-proofs');
                    const dateGroup = card.closest('.date-group');

                    // Immediately remove the entire card with animation - no placeholder, completely gone
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.9)';
                    card.style.transition = 'all 0.3s ease';
                    setTimeout(() => {
                        card.remove();

                        // Check if the date group is now empty
                        if (dateProofsContainer && dateProofsContainer.querySelectorAll('.proof-card').length === 0) {
                            // Remove the entire date group
                            if (dateGroup) {
                                dateGroup.style.opacity = '0';
                                dateGroup.style.transform = 'translateY(-10px)';
                                dateGroup.style.transition = 'all 0.3s ease';
                                setTimeout(() => {
                                    dateGroup.remove();

                                    // Check if there are any date groups left
                                    const container = document.getElementById('proofsGrid');
                                    const remainingGroups = container.querySelectorAll('.date-group');

                                    if (remainingGroups.length === 0) {
                                        container.innerHTML = `< p class="text-center text-muted" > No screenshots generated yet.Go to Messages to generate screenshots.</p > `;
                                    }
                                }, 300);
                            }
                        } else {
                            // Check if there are any cards left in the entire container
                            const container = document.getElementById('proofsGrid');
                            const remainingCards = container.querySelectorAll('.proof-card');

                            if (remainingCards.length === 0) {
                                container.innerHTML = `< p class="text-center text-muted" > No screenshots generated yet.Go to Messages to generate screenshots.</p > `;
                            }
                        }
                    }, 300);
                } else {
                    // Fallback: reload everything
                    await init();
                }
            } catch (error) {
                console.error('Error deleting screenshot:', error);
                alert('Failed to delete screenshot. Please try again.');
            }
        }

        // Cropper instance
        let cropper = null;
        let currentScreenshotId = null;

        function editProof(screenshotId, imageUrl, event) {
            event.stopPropagation();
            currentScreenshotId = screenshotId;

            const modal = document.getElementById('cropModal');
            const cropImage = document.getElementById('cropImage');
            const saveModeSelect = document.getElementById('saveModeSelect');

            // Reset save mode to default (copy)
            if (saveModeSelect) {
                saveModeSelect.value = 'copy';
            }

            // Destroy existing cropper if any
            if (cropper) {
                cropper.destroy();
                cropper = null;
            }

            // Set image source
            cropImage.src = imageUrl;

            // Show modal
            modal.classList.add('active');

            // Initialize cropper when image loads
            const initCropper = function () {
                if (cropper) {
                    cropper.destroy();
                }

                cropper = new Cropper(cropImage, {
                    aspectRatio: NaN, // Free aspect ratio
                    viewMode: 1,
                    dragMode: 'move',
                    autoCropArea: 0.8,
                    restore: false,
                    guides: true,
                    center: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: false,
                    ready: function () {
                        console.log('Cropper ready');
                    }
                });
            };

            // Set up load handler
            cropImage.onload = initCropper;

            // If image is already loaded
            if (cropImage.complete && cropImage.naturalWidth > 0) {
                setTimeout(initCropper, 100);
            }
        }

        function closeCropModal() {
            const modal = document.getElementById('cropModal');
            modal.classList.remove('active');

            if (cropper) {
                cropper.destroy();
                cropper = null;
            }

            currentScreenshotId = null;
        }

        async function saveCroppedImage() {
            if (!cropper || !currentScreenshotId) {
                alert('No image selected for cropping');
                return;
            }

            try {
                // Get cropped canvas
                const canvas = cropper.getCroppedCanvas({
                    width: cropper.getCroppedCanvas().width,
                    height: cropper.getCroppedCanvas().height,
                    imageSmoothingEnabled: true,
                    imageSmoothingQuality: 'high',
                });

                // Convert to blob
                canvas.toBlob(async (blob) => {
                    if (!blob) {
                        alert('Failed to create cropped image');
                        return;
                    }

                    // Convert blob to base64
                    const reader = new FileReader();
                    reader.onerror = () => {
                        console.error('FileReader error');
                        alert('Failed to read cropped image. Please try again.');
                    };
                    reader.onloadend = async () => {
                        const base64data = reader.result;

                        if (!base64data) {
                            alert('Failed to convert image to base64. Please try again.');
                            return;
                        }

                        try {
                            console.log('Sending cropped image to server...');

                            // Check save mode from dropdown
                            const saveModeSelect = document.getElementById('saveModeSelect');
                            const saveMode = saveModeSelect ? saveModeSelect.value : 'copy';

                            let result;
                            if (saveMode === 'copy') {
                                // Save as new copy
                                console.log('Saving as new copy...');
                                result = await window.api.copyScreenshot(currentScreenshotId, base64data);
                                console.log('Copy result:', result);
                            } else {
                                // Replace original
                                console.log('Replacing original image...');
                                result = await window.api.updateScreenshot(currentScreenshotId, base64data);
                                console.log('Update result:', result);
                            }

                            // Close modal
                            closeCropModal();

                            // Reload proofs to show updated/new image
                            await init();

                            const successMessage = saveMode === 'copy'
                                ? 'Image saved as new copy successfully!'
                                : 'Image cropped and saved successfully!';
                            alert(successMessage);
                        } catch (error) {
                            console.error('Error saving cropped image:', error);
                            console.error('Error details:', error.message, error.stack);
                            alert(`Failed to save cropped image: ${error.message || 'Unknown error'}. Please check console for details.`);
                        }
                    };
                    reader.readAsDataURL(blob);
                }, 'image/png', 1.0);
            } catch (error) {
                console.error('Error cropping image:', error);
                alert('Failed to crop image. Please try again.');
            }
        }

        // Lightbox functions
        function openLightbox(imageUrl) {
            const lightbox = document.getElementById('lightbox');
            const lightboxImg = document.getElementById('lightboxImg');
            lightboxImg.src = imageUrl;
            lightbox.classList.add('active');
        }

        function closeLightbox() {
            const lightbox = document.getElementById('lightbox');
            lightbox.classList.remove('active');
        }

        // Close lightbox when clicking outside image
        document.getElementById('lightbox').addEventListener('click', (e) => {
            if (e.target === e.currentTarget || e.target.classList.contains('lightbox-content')) {
                closeLightbox();
            }
        });

        // Close modals on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeCropModal();
                closeLightbox();
            }
        });

        // Export Evidences function - changes all RE-CAPTURE buttons to download buttons
        function exportEvidences() {
            const reCaptureButtons = document.querySelectorAll('.re-capture-btn');
            reCaptureButtons.forEach(button => {
                const isFailed = button.getAttribute('data-is-failed') === 'true';
                if (!isFailed) {
                    button.textContent = 'download as png';
                    button.setAttribute('data-export-mode', 'true');
                }
            });
        }

        // Handle RE-CAPTURE or download based on current state
        function handleReCaptureOrDownload(messageId, url, text, screenshotId, imageUrl, isFailed, event) {
            event.stopPropagation();

            const button = event.target;
            const isExportMode = button.getAttribute('data-export-mode') === 'true';

            if (isExportMode && !isFailed) {
                // Download as PNG
                downloadScreenshotAsPng(imageUrl, screenshotId);
            } else {
                // Original RE-CAPTURE behavior
                reCaptureScreenshot(messageId, url, text, screenshotId, event);
            }
        }

        // Download screenshot as PNG
        function downloadScreenshotAsPng(imageUrl, screenshotId) {
            if (!imageUrl) {
                alert('No image available to download.');
                return;
            }

            // Create a temporary anchor element to trigger download
            const link = document.createElement('a');
            link.href = imageUrl;
            link.download = `evidence - ${screenshotId || Date.now()}.png`;

            // Set crossOrigin to handle CORS if needed
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = function () {
                try {
                    // Create a canvas to convert the image
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    // Convert canvas to blob and download
                    canvas.toBlob(function (blob) {
                        const url = URL.createObjectURL(blob);
                        link.href = url;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }, 'image/png');
                } catch (error) {
                    // Fallback: direct download
                    console.warn('Canvas conversion failed, using direct download:', error);
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            };

            img.onerror = function () {
                // Fallback: direct download if image load fails
                console.warn('Image load failed, using direct download');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            img.src = imageUrl;
        }

        // Init
        init();
    </script>
</body>

</html>