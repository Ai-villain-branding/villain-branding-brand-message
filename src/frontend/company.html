<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Company Messages | Villain Branding</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        .page-layout {
            margin-top: 2rem;
            margin-bottom: 2rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            transition: var(--transition);
            cursor: pointer;
        }

        .back-button:hover {
            color: var(--text-primary);
        }

        .back-button::before {
            content: '←';
            font-size: 1.2rem;
        }

        .sticky-header-section {
            background-color: var(--bg-primary);
            z-index: 80;
            padding-top: 1rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
            margin-bottom: 1.5rem;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .scrollable-messages-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 0.5rem;
            /* Hide scrollbar for Chrome, Safari and Opera */
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE and Edge */
        }

        .scrollable-messages-container::-webkit-scrollbar {
            display: none;
            /* Chrome, Safari and Opera */
        }

        .message-grid {
            display: grid;
            gap: 1.5rem;
        }

        .message-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 2rem;
            transition: var(--transition);
            position: relative;
            cursor: pointer;
        }

        .message-card:hover {
            border-color: var(--text-muted);
        }

        .message-card.selected {
            border-color: var(--accent);
            background: rgba(212, 175, 55, 0.05);
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .message-title {
            flex: 1;
            font-size: 1.5rem;
            font-weight: 300;
            user-select: none;
        }

        .message-header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-shrink: 0;
        }

        .message-page-count {
            font-size: 0.85rem;
            color: var(--text-muted);
            user-select: none;
            white-space: nowrap;
        }

        .message-checkbox {
            cursor: pointer;
            width: 24px;
            height: 24px;
            border: 1px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            background: transparent;
        }

        .message-checkbox:hover {
            border-color: var(--text-muted);
        }

        .message-card.selected .message-checkbox {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .message-card.selected .message-checkbox::after {
            content: '✓';
            font-size: 14px;
            font-weight: bold;
        }

        .message-checkbox input[type="checkbox"] {
            display: none;
        }

        .message-meta {
            margin-bottom: 0.5rem;
            user-select: none;
        }

        .message-reasoning {
            user-select: none;
        }

        .message-dropdown {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-dropdown-header {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .message-dropdown-url {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 0;
            color: var(--text-secondary);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: var(--transition);
            font-size: 0.9rem;
            word-break: break-all;
        }

        .message-dropdown-url:hover {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .url-checkbox {
            cursor: pointer;
            width: 20px;
            height: 20px;
            border: 1px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            background: transparent;
            flex-shrink: 0;
        }

        .url-checkbox:hover {
            border-color: var(--text-muted);
        }

        .url-checkbox.checked {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .url-checkbox.checked::after {
            content: '✓';
            font-size: 12px;
            font-weight: bold;
        }

        .url-checkbox input[type="checkbox"] {
            display: none;
        }

        .url-text {
            flex: 1;
        }

        .flex {
            display: flex;
        }

        .gap-2 {
            gap: 0.5rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .text-muted {
            color: var(--text-muted);
        }

        .text-sm {
            font-size: 0.875rem;
        }

        .italic {
            font-style: italic;
        }

        .mt-2 {
            margin-top: 0.5rem;
        }

        .message-delete-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: var(--transition);
            flex-shrink: 0;
        }

        .message-delete-btn:hover {
            background: rgba(220, 38, 38, 0.1);
            border-color: #dc2626;
            color: #dc2626;
        }

        /* Message Group Styles */
        .message-group {
            margin-bottom: 2rem;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            overflow: hidden;
            background: var(--bg-secondary);
        }

        .message-group-header {
            padding: 1.5rem 2rem;
            background: rgba(212, 175, 55, 0.1);
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
            user-select: none;
        }

        .message-group-header:hover {
            background: rgba(212, 175, 55, 0.15);
        }

        .message-group-header.expanded {
            border-bottom: 1px solid var(--border);
        }

        .message-group-title {
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--text-primary);
            text-transform: capitalize;
        }

        .message-group-count {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-left: 1rem;
        }

        .message-group-toggle {
            font-size: 1.5rem;
            color: var(--text-secondary);
            transition: transform 0.3s ease;
            flex-shrink: 0;
        }

        .message-group-header.expanded .message-group-toggle {
            transform: rotate(180deg);
        }

        .message-group-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .message-group-content.expanded {
            max-height: 10000px;
            transition: max-height 0.5s ease-in;
        }

        .message-group-messages {
            padding: 1.5rem;
            display: grid;
            gap: 1.5rem;
        }

        .message-group-header .message-group-title-section {
            display: flex;
            align-items: center;
            flex: 1;
        }
    </style>
</head>

<body>
    <header class="site-header">
        <div class="container nav-container">
            <div class="logo" onclick="window.location.href='index.html'" style="cursor: pointer;">
                VILLAIN <span>BRANDING™</span>
            </div>
            <nav class="nav-links">
                <a href="index.html" class="nav-link">DASHBOARD</a>
                <a href="companies.html" class="nav-link active">MESSAGES</a>
                <a href="#" class="nav-link" id="navEvidences">EVIDENCES</a>
            </nav>
        </div>
    </header>

    <div class="container page-layout">
        <div style="flex-shrink: 0;">
            <!-- Back Button -->
            <a href="companies.html" class="back-button">Back</a>

            <!-- Sticky Header Section -->
            <div class="sticky-header-section">
                <div class="header-row">
                    <div style="text-align: left;">
                        <h1 id="companyName" style="text-align: left;">Loading...</h1>
                        <p class="text-muted" id="companyUrl" style="text-align: left;">Fetching brand messages...</p>
                    </div>
                    <div>
                        <button id="generateEvidencesBtn" class="btn btn-primary" disabled>
                            GENERATE EVIDENCE (<span id="selectedCount">0</span>)
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scrollable Messages List -->
        <div class="scrollable-messages-container">
            <div id="messagesList" class="message-grid">
                <!-- Messages injected here -->
                <div style="padding: 4rem 0;">
                    <div class="spinner" style="margin: 0 0 1rem 0;"></div>
                    <p class="text-muted">Loading messages...</p>
                </div>
            </div>
        </div>
    </div>

    <script src="js/app.js"></script>
    <script>
        const companyId = window.api.getCompanyId();
        const companyName = document.getElementById('companyName');
        const companyUrl = document.getElementById('companyUrl');
        const messagesList = document.getElementById('messagesList');
        const generateEvidencesBtn = document.getElementById('generateEvidencesBtn');
        const selectedCount = document.getElementById('selectedCount');
        const navEvidences = document.getElementById('navEvidences');

        let messages = [];
        let categorizedData = null; // Will contain { categories: [...] } if AI categories exist
        let selectedIds = new Set();
        let openDropdowns = new Set();
        // Track selected URLs for each message: { messageId: Set of URLs }
        let selectedUrls = {};
        // Track expanded groups
        let expandedGroups = new Set();

        // Update Nav Links
        window.api.updateNavLinks(companyId);

        async function init() {
            if (!companyId) {
                window.location.href = 'companies.html';
                return;
            }

            try {
                // Fetch company details
                const companies = await window.api.getCompanies();
                const company = companies.find(c => c.id === companyId);

                if (company) {
                    document.getElementById('companyName').textContent = company.name || company.domain;
                    document.getElementById('companyUrl').textContent = company.url;
                } else {
                    document.getElementById('companyName').textContent = 'Company Messages';
                    document.getElementById('companyUrl').textContent = 'Unknown Company';
                }

                // Try to fetch AI categories first
                try {
                    const categoriesResponse = await window.api.getCompanyCategories(companyId);
                    if (categoriesResponse && categoriesResponse.categories && categoriesResponse.categories.length > 0) {
                        categorizedData = categoriesResponse;
                        // Flatten messages from categories for compatibility
                        messages = [];
                        categoriesResponse.categories.forEach(cat => {
                            if (cat.messages && cat.messages.length > 0) {
                                messages.push(...cat.messages);
                            }
                        });
                        console.log(`Loaded ${categoriesResponse.categories.length} AI categories`);
                    } else {
                        // No categories, fetch raw messages
                        messages = await window.api.getCompanyMessages(companyId);
                        categorizedData = null;
                    }
                } catch (categoryError) {
                    // Fall back to raw messages if category fetch fails
                    console.warn('Failed to fetch categories, using fallback:', categoryError);
                    messages = await window.api.getCompanyMessages(companyId);
                    categorizedData = null;
                }

                renderMessages();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('messagesList').innerHTML = `<p class="text-center text-error">Failed to load messages.</p>`;
            }
        }

        // Function to extract key themes/words from messages
        function extractThemes(messages) {
            const themeKeywords = [
                'change', 'transform', 'innovation', 'innovate', 'reinvent', 'reinvented',
                'modernize', 'modernizing', 'modernization', 'digital', 'digitalization',
                'cloud', 'ai', 'artificial intelligence', 'data', 'analytics',
                'customer', 'client', 'support', 'service', 'experience',
                'design', 'implement', 'run', 'operate', 'operations', 'autonomous',
                'accelerate', 'personalize', 'personalized', 'tech', 'technology',
                'talent', 'team', 'people', 'together', 'collaboration',
                'growth', 'success', 'potential', 'unlock', 'deliver', 'delight',
                'trust', 'trusted', 'partner', 'leading', 'leader',
                'solution', 'solutions', 'platform', 'service', 'services'
            ];

            // Group messages by common themes
            const groups = {};

            messages.forEach(msg => {
                const content = msg.content.toLowerCase();
                const words = content.split(/\s+/);

                // Find the most prominent theme keyword in this message
                let bestTheme = null;
                let bestScore = 0;

                themeKeywords.forEach(theme => {
                    const themeWords = theme.split(/\s+/);
                    let score = 0;

                    themeWords.forEach(themeWord => {
                        // Check if theme word appears in message
                        if (content.includes(themeWord)) {
                            // Give higher score for exact word matches
                            words.forEach(word => {
                                if (word === themeWord || word.startsWith(themeWord)) {
                                    score += 2;
                                } else if (word.includes(themeWord)) {
                                    score += 1;
                                }
                            });
                        }
                    });

                    if (score > bestScore) {
                        bestScore = score;
                        bestTheme = theme;
                    }
                });

                // If no theme found, use first significant word (3+ chars, not common words)
                if (!bestTheme || bestScore === 0) {
                    const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'this', 'that', 'these', 'those', 'we', 'you', 'they', 'it', 'our', 'your', 'their', 'its'];
                    const significantWords = words.filter(w => w.length >= 3 && !commonWords.includes(w.toLowerCase()));
                    if (significantWords.length > 0) {
                        bestTheme = significantWords[0].toLowerCase();
                    } else {
                        bestTheme = 'other';
                    }
                }

                // Capitalize theme for display
                const displayTheme = bestTheme.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

                if (!groups[displayTheme]) {
                    groups[displayTheme] = [];
                }
                groups[displayTheme].push(msg);
            });

            // Sort groups by number of messages (descending)
            const sortedGroups = Object.entries(groups).sort((a, b) => b[1].length - a[1].length);

            return sortedGroups;
        }

        function renderMessages() {
            const container = document.getElementById('messagesList');

            if (!messages || messages.length === 0) {
                container.innerHTML = `
                    <div class="message-group">
                        <div class="message-group-header">
                            <div class="message-group-title-section">
                                <span class="message-group-title">No Brand Messages Found</span>
                            </div>
                        </div>
                        <div class="message-group-content expanded">
                            <div class="message-group-messages">
                                <p class="text-muted">We couldn't find any brand messages for this company. Try re-analyzing or checking the URL.</p>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            let groupedMessages;

            // Use AI categories if available, otherwise fall back to keyword grouping
            if (categorizedData && categorizedData.categories && categorizedData.categories.length > 0) {
                // Group by AI categories
                groupedMessages = categorizedData.categories.map(cat => [
                    cat.name,
                    cat.messages || []
                ]).filter(([name, msgs]) => msgs.length > 0);
            } else {
                // Fall back to keyword-based grouping
                groupedMessages = extractThemes(messages);
            }

            // Render grouped messages
            container.innerHTML = groupedMessages.map(([theme, themeMessages]) => {
                const isExpanded = expandedGroups.has(theme);
                const messageCards = themeMessages.map(msg => renderMessageCard(msg)).join('');

                return `
                    <div class="message-group">
                        <div class="message-group-header ${isExpanded ? 'expanded' : ''}" onclick="toggleGroup('${theme.replace(/'/g, "\\'")}')">
                            <div class="message-group-title-section">
                                <span class="message-group-title">${theme}</span>
                                <span class="message-group-count">(${themeMessages.length} ${themeMessages.length === 1 ? 'message' : 'messages'})</span>
                            </div>
                            <span class="message-group-toggle">▼</span>
                        </div>
                        <div class="message-group-content ${isExpanded ? 'expanded' : ''}">
                            <div class="message-group-messages">
                                ${messageCards}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            updateButton();
        }

        function renderMessageCard(msg) {
            const locations = msg.locations || [];
            const pageCount = locations.length || msg.count || 0;
            const isDropdownOpen = openDropdowns.has(msg.id);

            // Generate dropdown HTML with checkboxes
            let dropdownHTML = '';
            if (locations.length > 0) {
                // Initialize selected URLs for this message if not exists
                if (!selectedUrls[msg.id]) {
                    selectedUrls[msg.id] = new Set();
                }

                const urlLinks = locations.map((url, index) => {
                    const isChecked = selectedUrls[msg.id].has(url);
                    const escapedUrl = url.replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '');
                    return `
                            <div class="message-dropdown-url" onclick="event.stopPropagation()">
                                <div class="url-checkbox ${isChecked ? 'checked' : ''}" onclick="toggleUrlCheckbox('${msg.id}', '${escapedUrl}', event)" style="cursor: pointer;" data-url="${escapedUrl}">
                                    <input type="checkbox" ${isChecked ? 'checked' : ''}>
                                </div>
                                <span class="url-text" onclick="toggleUrlCheckbox('${msg.id}', '${escapedUrl}', event)" style="cursor: pointer; flex: 1;" data-url="${escapedUrl}">${url}</span>
                                <a href="${url}" target="_blank" style="margin-left: 0.5rem; color: var(--accent); text-decoration: none;" onclick="event.stopPropagation()" title="Open in new tab">↗</a>
                            </div>
                        `;
                }).join('');

                dropdownHTML = `
                        <div class="message-dropdown" id="dropdown-${msg.id}" style="display: ${isDropdownOpen ? 'block' : 'none'};" onclick="event.stopPropagation()">
                            <div class="message-dropdown-header">Select pages to generate screenshots:</div>
                            ${urlLinks}
                        </div>
                    `;
            } else if (isDropdownOpen) {
                dropdownHTML = `
                        <div class="message-dropdown" id="dropdown-${msg.id}" style="display: block;">
                            <div class="message-dropdown-header">No page URLs available</div>
                        </div>
                    `;
            }

            return `
                <div class="message-card ${selectedIds.has(msg.id) ? 'selected' : ''}" id="card-${msg.id}" onclick="toggleDropdown('${msg.id}')">
                    <div class="message-header">
                        <h3 class="message-title">"${msg.content}"</h3>
                        <div class="message-header-right">
                            <div class="message-page-count">Found on ${pageCount} ${pageCount === 1 ? 'page' : 'pages'}</div>
                            <button class="message-delete-btn" onclick="deleteMessage('${msg.id}', event)" title="Delete message and all evidence">
                                ×
                            </button>
                            <div class="message-checkbox" onclick="toggleMessage('${msg.id}', event)">
                                <input type="checkbox" ${selectedIds.has(msg.id) ? 'checked' : ''}>
                            </div>
                        </div>
                    </div>
                    <div class="message-meta">
                        <div class="flex gap-2">
                            <span class="badge badge-secondary">${msg.message_type}</span>
                        </div>
                    </div>
                    <div class="message-reasoning">
                        <div class="mt-2 text-sm text-muted italic">
                            ${msg.reasoning || ''}
                        </div>
                    </div>
                    ${dropdownHTML}
                </div>
            `;
        }

        window.toggleGroup = (theme) => {
            if (expandedGroups.has(theme)) {
                expandedGroups.delete(theme);
            } else {
                expandedGroups.add(theme);
            }
            renderMessages();
        };

        window.toggleMessage = (id, event) => {
            // Stop propagation to prevent triggering dropdown toggle
            if (event) {
                event.stopPropagation();
            }

            if (selectedIds.has(id)) {
                selectedIds.delete(id);
                console.log(`Deselected message ${id}`);
            } else {
                selectedIds.add(id);
                console.log(`Selected message ${id}`);
            }
            renderMessages();
        };

        window.toggleDropdown = (id) => {
            if (openDropdowns.has(id)) {
                openDropdowns.delete(id);
            } else {
                openDropdowns.add(id);
            }

            // Toggle dropdown visibility without full re-render for better performance
            const dropdown = document.getElementById(`dropdown-${id}`);
            if (dropdown) {
                if (openDropdowns.has(id)) {
                    dropdown.style.display = 'block';
                } else {
                    dropdown.style.display = 'none';
                }
            }
        };

        window.toggleUrlCheckbox = (messageId, url, event) => {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }

            console.log('Toggle URL checkbox:', messageId, url);

            // Initialize if not exists
            if (!selectedUrls[messageId]) {
                selectedUrls[messageId] = new Set();
            }

            // Toggle URL selection
            const wasChecked = selectedUrls[messageId].has(url);
            if (wasChecked) {
                selectedUrls[messageId].delete(url);
            } else {
                selectedUrls[messageId].add(url);
            }

            console.log('Selected URLs for message', messageId, ':', Array.from(selectedUrls[messageId]));

            // Find and update the checkbox UI using data-url attribute
            const dropdown = document.getElementById(`dropdown-${messageId}`);
            if (dropdown) {
                const urlItems = dropdown.querySelectorAll('.message-dropdown-url');
                urlItems.forEach(item => {
                    const checkbox = item.querySelector('.url-checkbox');
                    const urlText = item.querySelector('.url-text');

                    // Check if this item matches the URL using data-url attribute
                    if (checkbox && checkbox.getAttribute('data-url') === url) {
                        const checkboxInput = item.querySelector('input[type="checkbox"]');
                        const isNowChecked = selectedUrls[messageId].has(url);

                        if (isNowChecked) {
                            checkbox.classList.add('checked');
                            if (checkboxInput) checkboxInput.checked = true;
                        } else {
                            checkbox.classList.remove('checked');
                            if (checkboxInput) checkboxInput.checked = false;
                        }
                    }
                });
            }

            // Update button state
            updateButton();
        };

        function updateButton() {
            const btn = document.getElementById('generateEvidencesBtn');
            const count = document.getElementById('selectedCount');

            // Count total selected URLs across all selected messages
            let totalSelectedUrls = 0;
            selectedIds.forEach(msgId => {
                // If user explicitly selected some URLs, use those
                if (selectedUrls[msgId] && selectedUrls[msgId].size > 0) {
                    totalSelectedUrls += selectedUrls[msgId].size;
                } else {
                    // If message is selected but no explicit URL selections, use all URLs
                    const msg = messages.find(m => m.id === msgId);
                    if (msg && msg.locations && msg.locations.length > 0) {
                        totalSelectedUrls += msg.locations.length;
                    }
                }
            });

            count.textContent = totalSelectedUrls;
            btn.disabled = totalSelectedUrls === 0;
        }

        window.deleteMessage = async (messageId, event) => {
            // Stop propagation to prevent triggering dropdown toggle
            if (event) {
                event.stopPropagation();
            }

            const msg = messages.find(m => m.id === messageId);
            const messageText = msg ? msg.content : 'this message';

            const confirmed = await window.api.confirm(
                `Are you sure you want to delete "${messageText}"? This will also delete all associated evidence (screenshots). This action cannot be undone.`,
                'Delete Message'
            );

            if (!confirmed) {
                return;
            }

            try {
                const result = await window.api.deleteMessage(messageId);

                if (result.success) {
                    // Remove from local state
                    messages = messages.filter(m => m.id !== messageId);
                    selectedIds.delete(messageId);
                    delete selectedUrls[messageId];
                    openDropdowns.delete(messageId);

                    // Update categorized data if it exists
                    if (categorizedData && categorizedData.categories) {
                        categorizedData.categories.forEach(cat => {
                            if (cat.messages) {
                                cat.messages = cat.messages.filter(m => m.id !== messageId);
                            }
                        });
                    }

                    // Re-render messages
                    renderMessages();

                    // Show success message
                    const evidenceCount = result.deletedScreenshots || 0;
                    const evidenceText = evidenceCount === 1 ? 'evidence' : 'pieces of evidence';
                    await window.api.alert(
                        `Message deleted successfully${evidenceCount > 0 ? ` along with ${evidenceCount} ${evidenceText}` : ''}.`,
                        'Success'
                    );
                } else {
                    throw new Error(result.error || 'Failed to delete message');
                }
            } catch (error) {
                console.error('Error deleting message:', error);
                await window.api.alert(
                    `Failed to delete message: ${error.message || 'Unknown error'}`,
                    'Error'
                );
            }
        };

        document.getElementById('generateEvidencesBtn').onclick = async () => {
            const btn = document.getElementById('generateEvidencesBtn');
            const countSpan = document.getElementById('selectedCount');

            // Validate that we have selected messages
            if (selectedIds.size === 0) {
                alert('Please select at least one message to generate evidence.');
                return;
            }

            console.log('Generate evidence clicked. Selected messages:', Array.from(selectedIds));
            console.log('Selected URLs:', selectedUrls);

            // Store original button content
            const originalButtonHTML = btn.innerHTML;

            btn.disabled = true;
            btn.innerHTML = 'STARTING...';

            try {
                // Build array of screenshot tasks
                const screenshotTasks = [];

                Array.from(selectedIds).forEach(msgId => {
                    const msg = messages.find(m => m.id === msgId);
                    if (!msg) {
                        console.warn(`Message with id ${msgId} not found`);
                        return;
                    }

                    console.log(`Processing message ${msgId}: "${msg.content}"`);

                    // Get URLs to screenshot for this message
                    let urlsToScreenshot = [];
                    if (selectedUrls[msgId] && selectedUrls[msgId].size > 0) {
                        urlsToScreenshot = Array.from(selectedUrls[msgId]);
                        console.log(`Using ${urlsToScreenshot.length} selected URLs for message ${msgId}`);
                    } else if (msg.locations && msg.locations.length > 0) {
                        urlsToScreenshot = msg.locations;
                        console.log(`Using all ${urlsToScreenshot.length} locations for message ${msgId}`);
                    }

                    if (urlsToScreenshot.length === 0) {
                        console.warn(`No URLs available for message ${msgId}`);
                        return;
                    }

                    // Create screenshot tasks for each URL
                    urlsToScreenshot.forEach(url => {
                        screenshotTasks.push({
                            companyId: companyId,
                            messageId: msgId,
                            url: url,
                            text: msg.content
                        });
                    });
                });

                if (screenshotTasks.length === 0) {
                    alert('No URLs available to generate screenshots. Please ensure selected messages have page URLs.');
                    btn.disabled = false;
                    btn.innerHTML = originalButtonHTML;
                    updateButton();
                    return;
                }

                console.log(`Submitting ${screenshotTasks.length} screenshots to batch endpoint...`);

                // Call batch endpoint - this returns immediately with pending IDs
                const response = await fetch('/api/screenshots/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tasks: screenshotTasks })
                });

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Batch request failed');
                }

                console.log(`Batch submitted successfully. ${result.pending.length} screenshots pending.`);

                // Store pending IDs in sessionStorage for the proofs page to poll
                sessionStorage.setItem('pendingScreenshots', JSON.stringify(result.pending));
                sessionStorage.setItem('currentBatchId', result.batchId);

                // Redirect immediately to proofs page with batchId
                window.location.href = `proofs.html?id=${companyId}&batchId=${result.batchId}`;

            } catch (error) {
                console.error('Error submitting batch:', error);
                alert('Failed to start screenshot generation. Check console for details.');
                btn.disabled = false;
                btn.innerHTML = originalButtonHTML;
                updateButton();
            }
        };

        // Init
        init();
    </script>
</body>

</html>